<HTML>
<HEAD>
<TITLE>Parse::RecDescent::FAQ</TITLE>
</HEAD>
<BODY BGCOLOR="#fffff8" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A></LI>
<LI><A HREF="#IGNORABLE%20TOKENS">IGNORABLE TOKENS 

</A></LI>
<UL>
<LI><A HREF="#Removing%20C%20comments">Removing C comments

</A></LI>
</UL>
<LI><A HREF="#NEWLINE%20PROCESSING">NEWLINE PROCESSING

</A></LI>
<UL>
<LI><A HREF="#As%20end%20of%20line">As end of line



</A></LI>
</UL>
<LI><A HREF="#COLUMN-ORIENTED%20PROCESSING">COLUMN-ORIENTED PROCESSING

</A></LI>
<UL>
<LI><A HREF="#Whitespace%2c%20text%2c%20column%20N%2c%20period%2c%20number%20(some%20reference%20to%20lookahead)">Whitespace, text, column N, period, number (some reference to lookahead)

</A></LI>
<LI><A HREF="#Another%20example">Another example

</A></LI>
</UL>
<LI><A HREF="#MODULAR%20%2f%20GENERATIVE%20%2f%20CREATIVE%20%2f%20HAIRY%20PARSING">MODULAR / GENERATIVE / CREATIVE / HAIRY PARSING

</A></LI>
<UL>
<LI><A HREF="#Parsing%20sentences%20to%20generate%20sentences">Parsing sentences to generate sentences

</A></LI>
<LI><A HREF="#Calling%20a%20parser%20within%20a%20grammar">Calling a parser within a grammar

</A></LI>
<LI><A HREF="#Incremental%20generation%20of%20data%20structure%20representing%20parse">Incremental generation of data structure representing parse

</A></LI>
</UL>
<LI><A HREF="#CLEANING%20UP%20YOUR%20GRAMMARS">CLEANING UP YOUR GRAMMARS

</A></LI>
<UL>
<LI><A HREF="#Use%20repetition%20modifiers%20with%20a%20separator%20pattern%20to%20match%0aCSV-like%20data">Use repetition modifiers with a separator pattern to match
CSV-like data

</A></LI>
</UL>
<LI><A HREF="#OPTIMIZING%20YOUR%20GRAMMARS">OPTIMIZING YOUR GRAMMARS

</A></LI>
<UL>
<LI><A HREF="#Eliminate%20backtracking%20when%20possible">Eliminate backtracking when possible

</A></LI>
<LI><A HREF="#Precompiling%20Grammars%20for%20Speed%20of%20Execution">Precompiling Grammars for Speed of Execution

</A></LI>
<LI><A HREF="#Parse%3a%3aRecDescent%20is%20slow%20on%20Really%20Big%20Files.%20How%20can%20I%20speed%20it%20up%3f">Parse::RecDescent is slow on Really Big Files. How can I speed it up?

</A></LI>
</UL>
<LI><A HREF="#CAPTURING%20MATCHES">CAPTURING MATCHES

</A></LI>
<UL>
<LI><A HREF="#Hey!%20I'm%20getting%20back%20ARRAY(0x355300)%20instead%20of%20what%20I%20set%20%24return%20to!">Hey! I'm getting back ARRAY(0x355300) instead of what I set $return to!

</A></LI>
<LI><A HREF="#Getting%20text%20from%20subrule%20matches">Getting text from subrule matches

</A></LI>
<LI><A HREF="#Capturing%20whitespace%20between%20tokens">Capturing whitespace between tokens

</A></LI>
<LI><A HREF="#My%20grammar%20is%20not%20returning%20any%20data!">My grammar is not returning any data! 

</A></LI>
</UL>
<LI><A HREF="#THINGS%20NOT%20TO%20DO">THINGS NOT TO DO

</A></LI>
<UL>
<LI><A HREF="#Do%20not%20follow%20%3cresync%3e%20with%20%3creject%3e%20to%20skip%20errors">Do not follow &lt;resync&gt; with &lt;reject&gt; to skip errors

</A></LI>
<LI><A HREF="#Do%20not%20assume%20that%20%25item%20contains%20an%20array%20ref%20of%20all%20text%20matched%20for%0aa%20particular%20subrule">Do not assume that %item contains an array ref of all text matched for
a particular subrule

</A></LI>
<LI><A HREF="#use%20%3crulevar%3a%20local%20%24x%3e%20not%20%3crulevar%3a%20%24x%3e">use &lt;rulevar: local $x&gt; not &lt;rulevar: $x&gt; 

</A></LI>
<LI><A HREF="#Don't%20use%20%24%3a%3aRD_AUTOACTION%20to%20print%20while%20you%20are%20parsing">Don't use $::RD_AUTOACTION to print while you are parsing

</A></LI>
</UL>
<LI><A HREF="#ERROR%20HANDLING">ERROR HANDLING

</A></LI>
<UL>
<LI><A HREF="#In%20a%20non-shell%20(e.g.%20CGI)%20environment">In a non-shell (e.g. CGI) environment

</A></LI>
<LI><A HREF="#Simple%20Error%20Handling">Simple Error Handling

</A></LI>
</UL>
<LI><A HREF="#OTHER%20Parse%3a%3aRecDescent%20QUESTIONS">OTHER Parse::RecDescent QUESTIONS


</A></LI>
<UL>
<LI><A HREF="#Matching%20line%20continuation%20characters">Matching line continuation characters

</A></LI>
<LI><A HREF="#How%20can%20I%20match%20parenthetical%20expressions%20to%20arbitrary%20depth%3f">How can I match parenthetical expressions to arbitrary depth?

</A></LI>
<LI><A HREF="#Switching%20out%20of%20first-match-wins%20mode">Switching out of first-match-wins mode

</A></LI>
<LI><A HREF="#I'm%20having%20problems%20with%20the%20inter-token%20separator%3a">I'm having problems with the inter-token separator:

</A></LI>
<LI><A HREF="#Matching%20blank%20lines">Matching blank lines

</A></LI>
<LI><A HREF="#How%20can%20I%20get%20at%20the%20text%20remaining%20to%20be%20parsed%3f">How can I get at the text remaining to be parsed?

</A></LI>
<LI><A HREF="#You%20don't%20escape%20Perl%20symbols%20in%20your%20grammars.%20Why%20did%20I%20have%20to%3f">You don't escape Perl symbols in your grammars. Why did I have to?

</A></LI>
<LI><A HREF="#Other%20modules%20appear%20to%20not%20work%20when%20used%20with%20P%3a%3aRD">Other modules appear to not work when used with P::RD

</A></LI>
</UL>
<LI><A HREF="#Programming%20Topics%20Germane%20to%20Parse%3a%3aRecDescent%20Use">Programming Topics Germane to Parse::RecDescent Use

</A></LI>
<UL>
<LI><A HREF="#Double%20vs%20Single-quoted%20strings">Double vs Single-quoted strings


</A></LI>
<LI><A HREF="#Tracking%20text%20parsed%20between%20phases%20of%20the%20parse">Tracking text parsed between phases of the parse


</A></LI>
<LI><A HREF="#Unconditionally%20listifying%20scalars">Unconditionally listifying scalars

</A></LI>
<LI><A HREF="#A%20tutorial%20on%20Shallow%20versus%20Deep%20Copying">A tutorial on Shallow versus Deep Copying 

</A></LI>
<LI><A HREF="#Apparent%2c%20but%20not%20really%20deep%20copying%3a%20%20my%20(%40list)%20%3d%20%40%7b%5b%40%7b%24_%5b0%5d%7d%5d%7d%3b">Apparent, but not really deep copying:  my (@list) = @{[@{$_[0]}]};

</A></LI>
</UL>
<LI><A HREF="#SEE%20ALSO">SEE ALSO

</A></LI>
<LI><A HREF="#AUTHOR">AUTHOR

</A></LI>
</UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>Parse::RecDescent::FAQ - the official, authorized FAQ for Parse::RecDescent. 

</P><H1><A NAME="IGNORABLE%20TOKENS">IGNORABLE TOKENS 

</A></H1>
<H2><A NAME="Removing%20C%20comments">Removing C comments

</A></H2>

<P>Since there is no separate lexer in recdescent. And it is top down. Is
there anyway to deal w/ removing C comments that could be anywhere.

</P><DL><DT><A NAME="*%20Answer%20by%20Conway">* Answer by Conway

</A></DT>
<DD>

<P>Sure. Treat them as whitespace!

</P>
<P>Do something like this:

</P>
<PRE>	program: &lt;skip: qr{\s* (/[*] .*? [*]/ \s*)*}x&gt; statement(s)</PRE>

<PRE>	statement: # etc...</PRE>
</DD>
</DL>
<H1><A NAME="NEWLINE%20PROCESSING">NEWLINE PROCESSING

</A></H1>
<H2><A NAME="As%20end%20of%20line">As end of line



</A></H2>

<P>I'm trying to parse a text line by line using Parse::RecDescent. Each
line is terminated by a &quot;\n&quot;.

</P>
<P>Although the task setting up a grammar for this case is straightforward
the following program doesn't
produce any results.


</P>
<PRE>     use Parse::RecDescent;</PRE>

<PRE>     $grammar =
     q{
         line:       word(s) newline { print &quot;Found a line\n&quot;; }
         word:       /\w+/
         newline : /\n/
     };</PRE>

<PRE>     $parse = new Parse::RecDescent ($grammar);
</PRE>

<PRE>     $data =
     qq(This is line one\nAnd this is line two\n);</PRE>

<PRE>     $parse-&gt;line($data);
</PRE>

<P>RecDescent doesn't recognize the newlines. Does anybody know what I'm
getting wrong?

</P><DL><DT><A NAME="*%20Answer%20by%20Damian">* Answer by Damian



</A></DT>
<DD>

<P>By default, P::RD skips all whitespace (*including* newlines) before
tokens. 

</P>
<P>Try this instead:

</P>
<PRE>         line:    &lt;skip: qr/[ \t]*/&gt; word(s) newline 
				{ print &quot;Found a line\n&quot;; }
         word:    /\w+/
         newline: /\n/</PRE>
</DD>
</DL>
<H1><A NAME="COLUMN-ORIENTED%20PROCESSING">COLUMN-ORIENTED PROCESSING

</A></H1>
<H2><A NAME="Whitespace%2c%20text%2c%20column%20N%2c%20period%2c%20number%20(some%20reference%20to%20lookahead)">Whitespace, text, column N, period, number (some reference to lookahead)

</A></H2>

<P>Ok, now the line I'm trying to deal with is:

</P>
<P>&quot;some amount of
whitespace,
then some text, then starting at column 48 a number, followed by a
period,
followed by another number&quot;.  I want to capture the text (the
&quot;title&quot;),
and the two numbers (major and minor versions)

</P><DL><DT><A NAME="*%20Answer%20by%20Damian%20Conway">* Answer by Damian Conway

</A></DT>
<DD>

<P>You really do want to use a regex here (to get the
lookahead/backtracking that RecDescent doesn't do).

</P>
<PRE>   line: m/^(\s*        		# leading whitespace
   	      (.*?)        		# the title
              (?:\s+(?=\d+\.\d+\s*$)) 	# the space preceeding the numbers
	    )
            (\d+)        		# the major version number
            \.
            (\d+)        		# the minor version number
	 /x
	 &lt;reject: length $1 != 47&gt;
	 { @{$return}{title major minor)} = ($2,$3,$4) }</PRE>
</DD>
</DL>
<H2><A NAME="Another%20example">Another example

</A></H2>

<P>I'm parsing some lines where the &quot;column formatting&quot; is fixed, i.e. a
particular line might be formally described as &quot;a single word followed by
some amount of whitespace followed by another word whose first character
begins at column 22&quot;. 

</P><DL><DT><A NAME="*%20A%20simple%20answer%20that%20is%20wrong%3a">* A simple answer that is wrong:


</A></DT>
<DD>

<P>Hmm, I guess I could make this simpler and do this:

</P>
<P>line: word &lt;reject: $thiscolumn != 22&gt; word
word: /\S+/

</P>
<P>right?

</P>
<P>Wrong. And the reason why is that The 

</P>
<PRE>  &lt;reject:...&gt; </PRE>

<P>won't skip any whitespace after the first word.

</P>
<P>You instead would want:

</P>
<PRE>	line: word '' &lt;reject: $thiscolumn != 22&gt; word</PRE>
</DD>
<DT><A NAME="*%20Restating%20it%20in%20the%20positive%20can%20be%20a%20GOTCHA%3a">* Restating it in the positive can be a GOTCHA:

</A></DT>
<DD>

<P>I'd state that in the positive instead:

</P>
<PRE>    line: word '' { $thiscolumn == 22 } word </PRE>

<P>This seems nice and more to the point, but unfortunately a failing conditional 
yields a false value but not necessarily an undef value. So in this case, you
might get back a <CODE>0</CODE> from evaluating this conditional, but unfortunately,
that does not lead to failure.

</P>
<P>On the other hand, &lt;reject&gt; is exactly the same as the action
 { undef } 
and is guaranteed to make a production fail immediately.

</P>
<P>So if you would like to state the test in the positive, then do this:

</P>
<PRE>   line: word '' { $thiscolumn == 22 || undef } word </PRE>
</DD>
</DL>
<H1><A NAME="MODULAR%20%2f%20GENERATIVE%20%2f%20CREATIVE%20%2f%20HAIRY%20PARSING">MODULAR / GENERATIVE / CREATIVE / HAIRY PARSING

</A></H1>
<H2><A NAME="Parsing%20sentences%20to%20generate%20sentences">Parsing sentences to generate sentences

</A></H2>

<P>In this column, Randal shows how to read text to generate more text.
He parses sentences to make Parse::RecDescent parse trees which he then
re-walks with random weightings to create new sentences.

</P>
<PRE> http://www.stonehenge.com/merlyn/LinuxMag/col04.html
</PRE>
<H2><A NAME="Calling%20a%20parser%20within%20a%20grammar">Calling a parser within a grammar

</A></H2>

<P>I have a script that uses Parse::RecDescent, in which I want to define 2
parsers. The grammar for the second parser has to call the first parser.

</P>
<P>Can I do this?

</P><DL><DT><A NAME="*%20yes%2c%20here's%20an%20example">* yes, here's an example

</A></DT>
<DD>

<PRE> 
 #!/usr/local/bin/perl -w
 use strict;
 use Parse::RecDescent;
 
 $::RD_ERRORS = 1;
 $::RD_WARN = 1;
 $::RD_HINT = 1;
 
 our $text_to_parse = &quot;&quot;;
 
 my $grammar1 = q{
 [...]
 }
 
 our $inner_parser = new Parse::RecDescent($grammar1);
 
 my $grammar2 = q{
 [...]
 
 rule: TEXT
 	{
 	  $text_to_parse = $item{TEXT};
           if (defined $text_to_parse) { print &quot;executing inner parse...\n&quot;; }
           my $p_text = $inner_parser-&gt;startrule($text_to_parse);
 	}
 
 [...]
 
 }
 
</PRE>
</DD>
</DL>
<H2><A NAME="Incremental%20generation%20of%20data%20structure%20representing%20parse">Incremental generation of data structure representing parse

</A></H2>

<P>I have a data structure which is

</P>
<P>a hash of entries
where
an entry is a list/array of sets

</P>
<P>I have also a grammar that can parse the syntax of the text files that
contain the data I want to fill this structure with. Until here
everything is ok.

</P>
<P>Problem: I cannot figure out how to actually FILL the parsed data into
the structure. I can only decide if a string is grammatically correct
or not.



</P><DL><DT><A NAME="*%20Answer%20by%20Marcel%20Grunaer">* Answer by Marcel Grunaer

</A></DT>
<DD>

<P>Try this grammar, which you have to feed the input as one big
string. It uses a global variable, $::res into which the results
are assembled. At the end the variable is also returned for
convenience.

</P>
<P>It basically parses a phrase and a list of meanings. Instead of
reconstructing what it just parsed at each step, it checks the
remaining text at various stages (using an idea taken from
Parse::RecDescent::Consumer) to see what the 'phrase' or 'meaning'
subrules just matched. The 'meanings' subrule then (implicitly)
returns a reference to an array of 'meaning' strings. That arrayref
is stored at the proper slot in the result hash.

</P>
<P>(Hope that explanation makes sense. I'm sure Damian can come up
with a grammar that's way more elegant and efficient...)


</P>
<PRE> 
 
 { sub consumer {
          my $text = shift;
          my $closure = sub { substr $text, 0, length($text) - 
 length($_[0]) }
 } }
 
 start : entry(s) { $::res }
 
 entry :
            comment
          | def
          | &lt;error&gt;
 
 def : &lt;rulevar: local $p_cons&gt;
 def : &lt;rulevar: local $p_text&gt;
 
 # The // skips initial whitespace so it won't end up in $p_text
 
 def :
      // { $p_cons = consumer($text) } phrase { $p_text = 
 $p_cons-&gt;($text) }
      '=' meanings ';'
      { $::res-&gt;{$p_text} = $item{meanings} }
 
 comment : /#.*(?=\n)/m
 
 phrase  : ident(s)
 
 ident   : /[\w&amp;\.'-]+/
 
 meanings : meaning(s /:/)
 
 meaning : &lt;rulevar: local $m_cons&gt;
 meaning : // { $m_cons = consumer($text) } element(s /,?/) 
 { $m_cons-&gt;($text) }
 
 element : alternation(s /\|/)
 
 alternation : expr(s /[+&gt;]/)
 
 expr : /!?/ term
 
 term : ident '(' meaning ')' | ident</PRE>
</DD>
</DL>
<H1><A NAME="CLEANING%20UP%20YOUR%20GRAMMARS">CLEANING UP YOUR GRAMMARS

</A></H1>

<P>In honor of the original (and greatest) Perl book on cleaning up your
Perl code, this section is written in the style of 
Joseph Hall's &quot;Effective Perl Programming&quot;

</P><H2><A NAME="Use%20repetition%20modifiers%20with%20a%20separator%20pattern%20to%20match%0aCSV-like%20data">Use repetition modifiers with a separator pattern to match
CSV-like data

</A></H2>

<P>The intuitive to match CSV data is this:

</P>
<PRE> CSVLine:
      NonFinalToken(s?) QuotedText
 NonFinalToken: 
      QuotedText Comma
      { $return = $item[1] }</PRE>

<P>or, in other (merlyn's) words, &quot;many comma terminated items followed by
one standalone item&quot;.

</P>
<P>Instead, take the approach shown by merlyn:

</P>
<PRE> CSVLine: QuotedText(s Comma) { use Data::Dumper; Dumper($item[1]) }</PRE>

<P>Then just define <CODE>QuotedText</CODE>, <CODE>Comma</CODE>, and you're done!

</P><H1><A NAME="OPTIMIZING%20YOUR%20GRAMMARS">OPTIMIZING YOUR GRAMMARS

</A></H1>
<H2><A NAME="Eliminate%20backtracking%20when%20possible">Eliminate backtracking when possible

</A></H2>

<P>Let's take a look at two computationally equivalent grammars:

</P>
<PRE> expression      :       unary_expr PLUS_OP expression
                 |       unary_expr</PRE>

<P>versus

</P>
<PRE> expression      :       unary_expr plus_expression
 plus_expression :       PLUS_OP expression
                 |       # nothing</PRE>

<P>The second one is more efficient because it does not have to do backtracking.

</P>
<P>The first one is more readable and more maintainable though. It is more 
readable because it doesnt have an empty rule. It is more maintainable because
as you add more expression types (minus_expression,
mult_expression...) you don't have to add an empty rule to each of
them. The top level description scales without change.

</P>
<P>But, if speed is what you want then the second one is the way to go. 

</P><H2><A NAME="Precompiling%20Grammars%20for%20Speed%20of%20Execution">Precompiling Grammars for Speed of Execution

</A></H2>

<P>Take a look at Parse::RecDescent's precompilation option

</P><H2><A NAME="Parse%3a%3aRecDescent%20is%20slow%20on%20Really%20Big%20Files.%20How%20can%20I%20speed%20it%20up%3f">Parse::RecDescent is slow on Really Big Files. How can I speed it up?

</A></H2>
<DL><DT><A NAME="*%20Reduce%20the%20%22depth%22%20of%20the%20grammar.%20Use%20fewer%20levels%0aof%20nested%20subrules.">* Reduce the &quot;depth&quot; of the grammar. Use fewer levels
of nested subrules.

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Where%20possible%2c%20use%20regex%20terminals%20instead%20of%20subrules.%20%20For%20%0aexample%2c%20instead%20of%3a">* Where possible, use regex terminals instead of subrules.  For 
example, instead of:

</A></DT>
<DD>

<PRE>		string: '&quot;' char(s?) '&quot;'</PRE>

<PRE>		char:   /[^&quot;\\]/
		    |   '\\&quot;'
		    |   '\\\\'</PRE>

<P>write:

</P>
<PRE>		string: /&quot;([^&quot;\\]|\\[&quot;\\])*&quot;/</PRE>
</DD>
<DT><A NAME="*%20Where%20possible%2c%20use%20string%20terminals%20instead%20of%20regexes.">* Where possible, use string terminals instead of regexes.

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Use%20repetitions%20or%20%3cleftop%3e%2f%3crightop%3e%20instead%20of%20recursion.">* Use repetitions or &lt;leftop&gt;/&lt;rightop&gt; instead of recursion.

</A></DT>
<DD>

<P>For example, instead of:

</P>
<PRE>		list:  '(' elems ')'
		elems: elem ',' elems
		     | elem</PRE>

<P>write:

</P>
<PRE>		list: '(' &lt;leftop: elem ',' elem&gt; ')'</PRE>

<P>or:

</P>
<PRE>		list: '('  elem(s /,/)  ')'</PRE>
</DD>
<DT><A NAME="*%20Factor%20out%20common%20prefixes%20in%20a%20set%20of%20alternate%20productions.">* Factor out common prefixes in a set of alternate productions.

</A></DT>
<DD>

<P>For example, instead of:
		
		id: name rank serial_num
		  | name rank hair_colour
		  | name rank shoe_size

</P>
<P>write:
		  
		id: name rank (serial_num | haircolour | shoe_size)

</P></DD>
<DT><A NAME="*%20Pre-parse%20the%20input%20somehow%20to%20break%20it%20into%20smaller%20sections.%0aParse%20each%20section%20separately.">* Pre-parse the input somehow to break it into smaller sections.
Parse each section separately.

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Precompile%20they%20grammar.%20This%20won't%20speed%20up%20the%20parsing%2c%20but%20it%0awill%20speed%20up%20the%20parser%20construction%20for%20big%20grammars%20(which%0aReally%20Big%20Files%20often%20require).">* Precompile they grammar. This won't speed up the parsing, but it
will speed up the parser construction for big grammars (which
Really Big Files often require).

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Consider%20whether%20you%20would%20be%20better%20porting%20your%20grammar%20to%0aParse%3a%3aYapp%20instead.">* Consider whether you would be better porting your grammar to
Parse::Yapp instead.

</A></DT>
<DD>
</DD>
</DL>
<H1><A NAME="CAPTURING%20MATCHES">CAPTURING MATCHES

</A></H1>
<H2><A NAME="Hey!%20I'm%20getting%20back%20ARRAY(0x355300)%20instead%20of%20what%20I%20set%20%24return%20to!">Hey! I'm getting back ARRAY(0x355300) instead of what I set $return to!

</A></H2>

<P>Here's a prime example of when this mistake is made:

</P>
<PRE> QuotedText: 
       DoubleQuote TextChar(s?) DoubleQuote
       { my $chars = scalar(@item) - 1;  
         $return = join ('', @item[2..$chars]) }</PRE>

<P>This rule is incorrectly written. The author thinks that <CODE>@item</CODE> will
have one <CODE>TextChar</CODE> from position 2 until all <CODE>TextChar</CODE>s are matched.
However, the true structure of <CODE>@item</CODE> is:

</P><DL><DT><A NAME="position%20one%3a%20the%20string%20matched%20by%20rule%20DoubleQuote">position one: the string matched by rule DoubleQuote

</A></DT>
<DD>
</DD>
<DT><A NAME="position%20two%3a%20array%20reference%20representing%20parse%20tree%20for%20TextChar(s%3f)">position two: array reference representing parse tree for TextChar(s?)

</A></DT>
<DD>
</DD>
<DT><A NAME="position%20three%3a%20the%20string%20matched%20by%20rule%20DoubleQuote">position three: the string matched by rule DoubleQuote

</A></DT>
<DD>
</DD>
</DL>

<P>Note that position two is an array reference. So the rule must be
rewritten in this way.

</P>
<PRE> QuotedText: 
       DoubleQuote TextChar(s?) DoubleQuote
       { $return = join ( '', @{$item[2]} ) }
     </PRE>
<H2><A NAME="Getting%20text%20from%20subrule%20matches">Getting text from subrule matches

</A></H2>

<P>I can't seem to get the text from my subrule matches...

</P>
<P>Your problem is in this rule:

</P>
<PRE>    tuple : (number dot)(2)</PRE>

<P>is the same as:

</P>
<PRE>    tuple        : anon_subrule(2)</PRE>

<PRE>    anon_subrule : number dot</PRE>

<P>Like all subrules, this anonymous subrule returns only its last item
(namely, the dot). If you want just the number back, write this:

</P>
<PRE>    tuple : (number dot {$item[1]})(2)</PRE>

<P>If you want both number and dot back (in a nested array), write this:

</P>
<PRE>    tuple : (number dot {\@item})(2)</PRE>
<H2><A NAME="Capturing%20whitespace%20between%20tokens">Capturing whitespace between tokens

</A></H2>

<P>I need to capture the whitespace between tokens using Parse::RecDescent.
I've tried modifying the $skip expression to // or /\b/ (so I can tokenize
whitespace), but that doesn't seem to have the desired effect.

</P>
<P>Just having a variable where all skipped whitespace is stored would be
sufficient.

</P>
<P>Does anybody know how to trick Parse::RecDescent into doing this?

</P><DL><DT><A NAME="*%20Answer%20by%20Damian%20Conway">* Answer by Damian Conway

</A></DT>
<DD>

<P>To turn off whitespace skipping so I can handle it manually, I always use:

</P>
<PRE>	&lt;skip:''&gt;</PRE>

<P>See:

</P>
<PRE>	demo_decomment.pl
	demo_embedding.pl
	demo_textgen.pl</PRE>

<P>for examples.

</P></DD>
</DL>
<H2><A NAME="My%20grammar%20is%20not%20returning%20any%20data!">My grammar is not returning any data! 

</A></H2>

<P>What's wrong?!

</P><DL><DT><A NAME="*%20Answer%20by%20Brent%20Dax%3a">* Answer by Brent Dax:

</A></DT>
<DD>

<P>This is a clue; either something is wrong with your actions or the
grammar isn't parsing the data correctly. Try adding 
  | &lt;error&gt; 

</P>
<P>clauses
to the end of each top-level rule. This will tell you if there's a
parsing error, and possibly what the error is. If this doesn't show
anything, look hard at the actions. You may want to explicitly set the
$return variable in the actions.   

</P></DD>
</DL>
<H1><A NAME="THINGS%20NOT%20TO%20DO">THINGS NOT TO DO

</A></H1>
<H2><A NAME="Do%20not%20follow%20%3cresync%3e%20with%20%3creject%3e%20to%20skip%20errors">Do not follow &lt;resync&gt; with &lt;reject&gt; to skip errors

</A></H2>

<P><CODE>resync</CODE> is used to allow a rule which would normally fail to &quot;pass&quot; so that 
parsing can continue. If you add the reject, then it unconditionally fails.

</P><H2><A NAME="Do%20not%20assume%20that%20%25item%20contains%20an%20array%20ref%20of%20all%20text%20matched%20for%0aa%20particular%20subrule">Do not assume that %item contains an array ref of all text matched for
a particular subrule

</A></H2>

<P>For example: 

</P>
<PRE>        range: '(' number '..' number )'
                        { $return = $item{number} }</PRE>

<P>will return only the value corresponding to the last match of the <CODE>number</CODE>
subrule.

</P>
<P>To get each value for the number subrule, you have a couple of choices,
both documented in the Parse::RecDescent manpage under
<CODE>@item and %item</CODE>.

</P><H2><A NAME="use%20%3crulevar%3a%20local%20%24x%3e%20not%20%3crulevar%3a%20%24x%3e">use &lt;rulevar: local $x&gt; not &lt;rulevar: $x&gt; 

</A></H2>

<P>If you say:

</P>
<PRE>	somerule: &lt;rulevar: $x&gt;</PRE>

<P>you get a lexical $x within the rule (only). If you say:

</P>
<PRE>	somerule: &lt;rulevar: local $x&gt;</PRE>

<P>you get a localized $x within the rule (and any subrules it calls).

</P><H2><A NAME="Don't%20use%20%24%3a%3aRD_AUTOACTION%20to%20print%20while%20you%20are%20parsing">Don't use $::RD_AUTOACTION to print while you are parsing

</A></H2>

<P>You can't print out your result while you are parsing it, because you
can't &quot;unprint&quot; a backtrack.

</P>
<P>Instead, have the final top-level rule do all the diagnostic printing, or
alternatively use P::RD's tracing functionality to observe parsing in 
action.

</P><H1><A NAME="ERROR%20HANDLING">ERROR HANDLING

</A></H1>
<H2><A NAME="In%20a%20non-shell%20(e.g.%20CGI)%20environment">In a non-shell (e.g. CGI) environment

</A></H2>

<P>I need to parse a file with a parser that I cooked up from
Parse::Recdescent. 
My problem, it must work in a cgi environment and the script must be
able to handle errors. I tried eval, piping, forking, Tie::STDERR, but
the errors msgs from Parse::Recdescent seem unstoppable.

</P>
<P>I can catch them only by redirecting the script's STDERR from the
shell. But howdo I catch them from within ??

</P><DL><DT><A NAME="*%20Like%20this%3a">* Like this:

</A></DT>
<DD>

<PRE>        use Parse::RecDescent;
        open (Parse::RecDescent::ERROR, &quot;&gt;errfile&quot;)
                or die &quot;Can't redirect errors to file 'errfile'&quot;;</PRE>

<PRE>        # your program here</PRE>
</DD>
</DL>
<H2><A NAME="Simple%20Error%20Handling">Simple Error Handling

</A></H2>

<P>I'm trying to write a parser for orders for Atlantis (PBEM game).
Syntax is pretty simple: one line per command, each command
starts with name, followed by list of parameters. Basically it's
something like this (grammar for parsing one line):

</P>
<PRE> Statement:Comment | Command Comment(?)
 Comment:/;.*/ 
 Command:'#atlantis' &lt;commit&gt; FactionID String
    Command:'attack' &lt;commit&gt; Number(s)
 ....</PRE>

<P>However I have problems to make it work as I want:

</P>
<P>1) In case of failed parsing (syntax error, not allowey keyword, ...) 
I want to store error messages in variable (not to be just printed), so I can 
process them later.

</P>
<P>I don't think Parse::RecDescent has a hook for that (Damian, something
for the todo list?), but you can always install a $SIG {__WARN__}
handler and process the generated warnings.

</P>
<P>2) In case if user types &quot;attack bastards&quot; I want to give him
error message that &quot;list of numbers expected&quot; instead
of just saying the &quot;cannot parse this line&quot;. The only
thing that I came up with now was defining every command
like this:
 Command:Attack
 Attack:'attack' AttackParams
 AttackParams:Number(s) | &lt;error&gt;
 ...
Any better solutions?

</P><DL><DT><A NAME="*%20You%20can%20just%20do%3a">* You can just do:

</A></DT>
<DD>

<PRE>    Command:   '#atlantis' &lt;commit&gt; FactionID String
       |   'attack' &lt;commit&gt; Number(s)
       |   &lt;error&gt;</PRE>

<P>and when you try to parse &quot;attack bastards&quot;, you will get:

</P>
<PRE>    ERROR (line 1): Invalid Command: Was expecting Number but found
        &quot;bastards&quot; instead</PRE>

<P>You might want to use &lt;error?&gt;, which will only print the error when
it saw '#atlantis' or 'attack' (because then you are committed).

</P></DD>
</DL>
<H1><A NAME="OTHER%20Parse%3a%3aRecDescent%20QUESTIONS">OTHER Parse::RecDescent QUESTIONS


</A></H1>
<H2><A NAME="Matching%20line%20continuation%20characters">Matching line continuation characters

</A></H2>

<P>I need to parse a grammar that includes line continuation
characters.  For example:

</P>
<PRE> // COMMAND ARG1-VALUE,ARG2-VALUE, +
    ARG3-VALUE,ARG4-VALUE, +
    EVEN-MORE-ARGS
 // ANOTHERCOMMAND
 * and a comment
 * or two</PRE>

<P>How do I formulate a rule (or rules) to treat the first command
as if all 5 arguments were specified on a single line?  I need to
skip over the /\s*+\n\s*/ sequence.  It seems like skip or resync
should do this for me, but if so, I haven't discovered the
correct technique, yet.



</P><DL><DT><A NAME="*%20Answer%20by%20Damian%20Conway">* Answer by Damian Conway

</A></DT>
<DD>

<PRE> use Parse::RecDescent;
 
 my @lines = &lt;&lt; 'EOINST';
 // COMMAND ARG1-VALUE,ARG2-VALUE, +
    ARG3-VALUE,ARG4-VALUE, +
    EVEN-MORE-ARGS
 // ANOTHERCOMMAND
 * and a comment
 * or two
 EOINST
 
 my $parse = Parse::RecDescent-&gt;new(join '', &lt;DATA&gt;) or die &quot;Bad Grammar!&quot;;
 
 use Data::Dumper 'Dumper';
 print Dumper [
 $parse-&gt;Instructions(&quot;@lines&quot;) or die &quot;NOT parsable!!\n&quot;
 ];
 
 __DATA__
 
 Instructions: command(s)
 
 command: multiline_command
        | singleline_command
        | comment
 
 singleline_command: 
 	'//'  /.*/
 		{ {command =&gt; $item[-1]} }
 
 multiline_command:  
 	'//' /(.*?[+][ \t]*\n)+.*/
 		{ $item[-1] =~ s/[+][ \t]*\n//g; {command =&gt; $item[-1]} }
 
 comment:
 	'*'  /.*/
 		{ {comment =&gt; $item[-1]} }
 
</PRE>
</DD>
</DL>
<H2><A NAME="How%20can%20I%20match%20parenthetical%20expressions%20to%20arbitrary%20depth%3f">How can I match parenthetical expressions to arbitrary depth?

</A></H2>

<P>Example: a, (b ,c, (e,f , [h, i], j) )

</P><DL><DT><A NAME="*%20Answer%20by%20FAQ%20author">* Answer by FAQ author

</A></DT>
<DD>
Maybe Text::Balanced is enough for your needs. See it on search.CPAN.org
under author id DCONWAY.

</DD>
<DT><A NAME="*%20Answer%20by%20lhoward%20of%20perlmonks.org%3a">* Answer by lhoward of perlmonks.org:

</A></DT>
<DD>

<P>Parse::RecDescent implements a full-featured recursive-descent
parser. A real parser (as opposed to parsing a string with a regular
expression alone) is much more powerful and can be more apropriate for
parsing highly structured/nested data like you have. It 
has been a while since I've written a grammer so it may look a bit
rough. 

</P>
<PRE> use Parse::RecDescent;
 my $teststr=&quot;blah1,blah2(blah3,blah4(blah5,blah6(blah7))),blah8&quot;;
 my $grammar = q {
         content:        /[^\)\(\,]+/
         function:       content '(' list ')'
         value:          content
         item:           function | value
         list:           item ',' list | item
         startrule:      list
 };
 my $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;
 
 defined $parser-&gt;startrule($teststr) or print &quot;Bad text!\n&quot;;
</PRE>

<P>To which merlyn (Randal Schwartz) of perlmonks.org says:

</P>
<P>Simplifying the grammar, we get: 

</P>
<PRE> use Parse::RecDescent;  
 my $teststr=&quot;blah1,blah2(blah3,blah4(blah5,blah6(blah7))),blah8&quot;;  
 my $grammar = q {
  list: &lt;leftop: item ',' item&gt; 
  item: word '(' list ')' &lt;commit&gt;
      | word 
  word: /\w+/  
 };  
 my $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;
 
 defined $parser-&gt;list($teststr) or print &quot;Bad text!\n&quot;;</PRE>

<PRE> </PRE>
</DD>
</DL>
<H2><A NAME="Switching%20out%20of%20first-match-wins%20mode">Switching out of first-match-wins mode

</A></H2>

<P>I have a set of alternatives on which I want to avoid the
default first-match-wins behavior of Parse::RecDescent. How do I do
it? 

</P>
<P>Use a scored grammar. For example, this scoring directive

</P>
<PRE> opcode: /$match_text1/  &lt;score: { length join '' @item}&gt;
 opcode: /$match_text2/  &lt;score: { length join '' @item}&gt;
 opcode: /$match_text3/  &lt;score: { length join '' @item}&gt;</PRE>

<P>would return the opcode with the longest length, as opposed to which
one matched first.

</P>
<P>Just look for the section &quot;Scored productions&quot; in the .pod
documentation. 


</P><H2><A NAME="I'm%20having%20problems%20with%20the%20inter-token%20separator%3a">I'm having problems with the inter-token separator:

</A></H2>

<PRE> my $parse = Parse::RecDescent-&gt;new(&lt;&lt;'EndGrammar');</PRE>

<PRE> rebol   : block  { dump_item('block', \@item)  }
         | scalar { dump_item('scalar', \@item) }</PRE>

<PRE> block       : '[' block_stuff(s?) ']'
 block_stuff : scalar
 scalar      : &lt;skip:''&gt; '%' file
 file        : /w+/</PRE>

<PRE> EndGrammar</PRE>

<P>My grammar matches a filename, ie: 

</P>
<PRE> %reb.html</PRE>

<P>just fine. However, it does not match a filename within a block, ie: 

</P>
<PRE> [ %reb.html ]</PRE>

<P>and I know exactly why after tracing the grammar. 

</P>
<P>It is trying the 

</P>
<PRE> &lt;skip:''&gt; '%' file</PRE>

<P>production with the input text 

</P>
<PRE> &quot; %reb.html&quot;</PRE>

<P>note the space in the input text. 

</P>
<P>The reason this distresses me is that I have not changed the universal token 
separator from 

</P>
<PRE> /\s*/</PRE>

<P>Yet it did not gobble up the white space between the '[' terminal and the &lt;skip:''&gt;'%' file production


</P><DL><DT><A NAME="*%20Answer%20by%20Randal%20Schwartz">* Answer by Randal Schwartz

</A></DT>
<DD>

<P>That's the expected behavior. The outer prefix is in effect until
changed, but you changed it early in the rule, so the previous
&quot;whitespace skip&quot; is effectively gone by the time you hunt for '%'.  

</P>
<P>To get what you want, you want: 

</P>
<PRE> '%' &lt;skip:''&gt; file</PRE>

<P>in your rule. 
back

</P></DD>
</DL>
<H2><A NAME="Matching%20blank%20lines">Matching blank lines

</A></H2>

<P>How do I match an arbitrary number of blank lines in Parse::RecDescent?

</P><DL><DT><A NAME="*%20Answer%20by%20Damian%20Conway">* Answer by Damian Conway

</A></DT>
<DD>

<P>Unless you use the /m suffix, the trailing $ means &quot;end of string&quot;, 
not &quot;end of line&quot;. You want:

</P>
<PRE>   blank_line:  /^\s+?$/m</PRE>

<P>or 
   
   blank_line:  /^\s+?\n/

</P></DD>
</DL>

<P>I have a rule which MUST be failing, but it isn't. Why?


</P>
<PRE>   blank_line:    { $text =~ /silly-regex/ }
   
          parses with no error.</PRE>

<P>The pattern match still fails, but returns the empty string (&quot;&quot;).
Since that's not undef, the rule matches (even though it doesn't
do what you want).

</P><H2><A NAME="How%20can%20I%20get%20at%20the%20text%20remaining%20to%20be%20parsed%3f">How can I get at the text remaining to be parsed?

</A></H2>

<P>See the documentation for the <CODE>$text</CODE> variable.

</P><H2><A NAME="You%20don't%20escape%20Perl%20symbols%20in%20your%20grammars.%20Why%20did%20I%20have%20to%3f">You don't escape Perl symbols in your grammars. Why did I have to?

</A></H2>

<PRE> my $grammar = &lt;&lt;EOGRAMMAR;
 
 export_line:	stock_symbol	COMMA   # 1
 		stock_name	COMMA2  # 2
 		stock_code	COMMA3  # 3
 		trade_side	COMMA4  # 4
 		trade_volume	COMMA5  # 5
 		floating_point	COMMA6  # 6
 		tc                      # 7
 { print &quot;got \@item\n&quot;; }
     | &lt;error&gt;
 EOGRAMMAR
 
 Why does '@' have to be escaped? And whatever reason
 that may be, why doesnt it apply to '\n'?
 
</PRE>
<DL><DT><A NAME="*%20Answer%20by%20Damian%20Conway">* Answer by Damian Conway

</A></DT>
<DD>

<P>Because you're using an interpolating here document. You almost certainly 
want this instead: 

</P>
<PRE> my $grammar = &lt;&lt;'EOGRAMMAR';		# The quotes are critical!
    
 
  export_line:	stock_symbol	COMMA   # 1
    		stock_name	COMMA2  # 2
    		stock_code	COMMA3  # 3
    		trade_side	COMMA4  # 4
    		trade_volume	COMMA5  # 5
    		floating_point	COMMA6  # 6
    		tc                      # 7
  { print &quot;got @item\n&quot;; }
     | &lt;error&gt;
 EOGRAMMAR
 
</PRE>
</DD>
</DL>
<H2><A NAME="Other%20modules%20appear%20to%20not%20work%20when%20used%20with%20P%3a%3aRD">Other modules appear to not work when used with P::RD

</A></H2>

<P>Such-and-such a module works fine when I don't use Parse::RecDescent

</P>
<PRE> Did you alter the value of undef with your parser code? </PRE>

<P>The problem has nothing to do with  Parse::RecDescent.
 
Rather, it was caused by your having set $/ to undef, which seems to
have caused Mail::POP3 to over-read from its socket (that might be
considered a bug in the Mail::POP3 module).

</P>
<P>As a rule-of-thumb, *never* alter $/ without local-izing it. In other words, 
change things like this: 

</P>
<PRE>         $/ = undef;</PRE>

<P>to this:

</P>
<PRE>          {
          local $/;
          }</PRE>
<H1><A NAME="Programming%20Topics%20Germane%20to%20Parse%3a%3aRecDescent%20Use">Programming Topics Germane to Parse::RecDescent Use

</A></H1>
<H2><A NAME="Double%20vs%20Single-quoted%20strings">Double vs Single-quoted strings


</A></H2>

<P>I'm playing around with the &lt;skip:&gt; directive and I've noticed
something interesting that I can't explain to myself. 

</P>
<P>Here is my script:

</P>
<P>------ Start Script ------
use strict;
use warnings;

</P>
<P>$::RD_TRACE = 1;

</P>
<P>use Parse::RecDescent;

</P>
<P>my $grammar = q{

</P>
<PRE>   input:  number(s) { $return = $item{ number } } | &lt;error&gt;</PRE>

<PRE>   number: &lt;skip: '\.*'&gt; /\d+/ </PRE>

<P>};

</P>
<P>my $parser = new Parse::RecDescent($grammar);

</P>
<P>my $test_string = qq{1.2.3.5.8};

</P>
<P>print join( &quot;\n&quot;, @{ $parser -&gt; input( $test_string ) } );
------ End Script ------

</P>
<P>This script works great. However, if I change the value of the skip
directive so that it uses double quotes instead of single quotes:

</P>
<P>&lt;skip: &quot;\.*&quot;&gt;

</P>
<P>the grammar fails to parse the input. However, if I put square
brackets around the escaped dot:

</P>
<P>&lt;skip: &quot;[\.]*&quot;&gt;

</P>
<P>the grammar starts working again:

</P>
<P>How does this work this way?

</P><DL><DT><A NAME="*%20Damian%20says%3a">* Damian says:



</A></DT>
<DD>

<P>This small test program may help you figure out what's going wrong:

</P>
<PRE>	print &quot;\.*&quot;, &quot;\n&quot;;
	print '\.*', &quot;\n&quot;;</PRE>

<P>Backslash works differently inside single and double quotes.
Try:

</P>
<PRE>      &lt;skip: &quot;\\.*&quot;&gt;</PRE>

<P>The reason the third variant:

</P>
<PRE>      &lt;skip: &quot;[\.]*&quot;&gt;</PRE>

<P>works is because it becomes the pattern:

</P>
<PRE>	/[.]/</PRE>

<P>which is a literal dot.

</P></DD>
</DL>
<H2><A NAME="Tracking%20text%20parsed%20between%20phases%20of%20the%20parse">Tracking text parsed between phases of the parse


</A></H2>

<P>I wanted to know, after matching a rule, what text the rule matched.
So I used two variables to remember what the remaining text and
offset were before and after the rule and just determined the
difference.

</P>
<PRE>   report : &lt;rulevar: local $rule_text&gt;
   report : &lt;rulevar: local $rule_offset&gt;</PRE>

<PRE>   report :
             {
                 $rule_text   = $text;
                 $rule_offset = $thisoffset;
             }</PRE>

<PRE>         ...some subrules...</PRE>

<PRE>             {
                 my $str = substr($rule_text, 0, $thisoffset - 
$rule_offset);</PRE>

<PRE>                 # remove all sorts of whitespace</PRE>

<PRE>                 $str =~ s/^\s*//s;
                 $str =~ s/\s*$//s;
                 $str =~ s/\s+/ /gs;</PRE>

<PRE>                 # Now $str contains the text matched by this rule
             }</PRE>

<P>This is the kind of thing I thought would have been possible a lot
easier. Did I miss something?

</P>
<P>If not, is there a way to make this available in every parser,
e.g. by providing a new directive or something like that?

</P><DL><DT><A NAME="*%20The%20answer%20is%20on%20CPAN">* The answer is on CPAN

</A></DT>
<DD>
Parse::RecDescent::Consumer, on CPAN, prints out the text consumed
between stages of a parse... even if that part may fail later. The
implementation is straightforward, it creates closures containing
<CODE>$text</CODE> and evaluates them later to get the text consumed.

</DD>
</DL>
<H2><A NAME="Unconditionally%20listifying%20scalars">Unconditionally listifying scalars

</A></H2>

<P>Quite often when using Parse::RecDescent, I want to treat the return value of 
a production the same regardless of whether P::RD returns a string or a 
list of string.

</P><H2><A NAME="A%20tutorial%20on%20Shallow%20versus%20Deep%20Copying">A tutorial on Shallow versus Deep Copying 

</A></H2>

<P>Written by &quot;Philip 'Yes, that's my address' Newton&quot; &lt;nospam.newton@gmx.li&gt;

</P>
<P>Start off with an array of (references to) arrays: 

</P>
<PRE>    @array = ( [1,2,3], ['a', 'u', 'B', 'Q', 'M'], ['%'] );
</PRE>

<P>Now a shallow copy looks like this: 

</P>
<PRE>    @shallow = ( $array[0], $array[1], $array[2] );
</PRE>

<P>This copies the references over from @array to @shallow. Now @shallow
is ( [1,2,3], ['a', 'u', 'B', 'Q', 'M'], ['%'] ) -- the same as
@array. But there's only one 2 and one 'Q', since there are two
references pointing to the same place.  

</P>
<P>Here's what it looks like in the debugger: 

</P>
<PRE>  DB&lt;5&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'B'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;6&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'B'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
</PRE>

<P>You can see that @array lives somewhere around 0x10e5560, whereas
@shallow lives around 0xcaef60, but the three references point to
arrays in the same place. If I now change $array[1][2] to 'C', watch
what happens:  

</P>
<PRE>  DB&lt;7&gt; $array[1][2] = 'C'
</PRE>

<PRE>  DB&lt;8&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;9&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'</PRE>

<P>$shallow[1][2] is now also 'C'! This is because it just followed the
pointer to the array at 0x10e5638 and found the modified data there.  

</P>
<P>Now see what happens when I do a copy that's one level deeper -- not
just copying the references but the data behind the references:  

</P>
<PRE> @deep = ( [ @{$array[0]} ], [ @{$array[1]} ], [ @{$array[2]} ] );</PRE>

<P>This uses the knowledge that @array[0..2] are all references to
arrays, and it only goes one level deeper. A more general algorithm
(such as Storable's dclone, mentioned in `perldoc -q copy`) would do a
walk and copy differently depending on the type of reference it
encounters at each stage.  

</P>
<P>Now watch: 

</P>
<PRE>  DB&lt;12&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;13&gt; x \@deep
 0  ARRAY(0x10ef89c)
   0  ARRAY(0x10eb298)
      0  1
      1  2
      2  3
   1  ARRAY(0x10eb2c4)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10ef07c)
      0  '%'
</PRE>

<P>The references point to different places. 

</P>
<P>Now if you change @array, @deep doesn't change: 

</P>
<PRE>  DB&lt;14&gt; push @{$array[2]}, '$'
</PRE>

<PRE>  DB&lt;15&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
      1  '$'
  DB&lt;16&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
      1  '$'
  DB&lt;17&gt; x \@deep
 0  ARRAY(0x10ef89c)
   0  ARRAY(0x10eb298)
      0  1
      1  2
      2  3
   1  ARRAY(0x10eb2c4)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10ef07c)
      0  '%'
</PRE>

<P>@deep didn't change, since it's got its own value of the anonymous
array containing '%', but @shallow did.  

</P>
<P>Hope this helps a bit. 

</P>
<P>Cheers, Philip -- Philip Newton &lt;nospam.newton@gmx.li&gt; 
If you're not part of the solution, you're part of the precipitate

</P><H2><A NAME="Apparent%2c%20but%20not%20really%20deep%20copying%3a%20%20my%20(%40list)%20%3d%20%40%7b%5b%40%7b%24_%5b0%5d%7d%5d%7d%3b">Apparent, but not really deep copying:  my (@list) = @{[@{$_[0]}]};

</A></H2>

<P>I was meandering through demo_calc.pl in the Parse::RecDescent demo
directory and came across this 

</P>
<PRE> sub evalop
 {
        my (@list) = @{[@{$_[0]}]};
        my $val = shift(@list)-&gt;();
 ...       
 }</PRE>

<P>I took the line that confused me step-by-step and don't get the
purpose of this. Working from inner to outer: 


</P>
<PRE>   @{$_[0]}     # easy --- deference an array reference
 [  @{$_[0]} ]    # ok --- turn it back into an array ref.. why?
 @{ [ @{$_[0]} ] } # umm -- uh.... well, the @sign implies
                             # we have an array, but how is it 
                             # different from the first array we
                             # dereferenced?</PRE>
<DL>
<P>The line from demo_calc.pl is in
fact not doing any deep copying.


</P>
<PRE>    #!/usr/bin/perl -w
    my @original = (
        [0],  [1,2,3],  [4,5,6],  [7,8,9]
    );
    my @copy = &amp;some_kind_of_copy( \@original );
    sub some_kind_of _copy {
        # here's that line from demo_calc.pl
        my (@list) = @{[@{$_[0]}]};
        return @list;
    }</PRE>

<PRE> $original[0][0]         = 'zero';
 @{ $original[1] }[0..2] = qw(one   two   three);
 @{ $original[2] }[0..2] = qw(four  five  six);
 @{ $original[3] }[0..2] = qw(seven eight nine);
    # now use the debugger to look at the addresses,
    # or use Data::Dumper to look at @copy, or just
    # compare one of the items...
 if (  $copy[1][2] eq 'three'  ) {
    print &quot;Shallow Copy\n&quot;;
 } elsif (  $copy[1][2] == 3  ) {
    print &quot;Deep Copy\n&quot;;
 } else {
        print &quot;This should never happen!!!\n&quot;
	}
</PRE>

<P>If you wanted that line to do deep copying of a list of anon arrays,
then the line should read

</P>
<PRE>    my @list = map  { [@$_] }  @{$_[0]};
               # turn $_[0] into a list (of arrayrefs)
               # turn each (arrayref) element of that list
               # into an anonymous array containing
               # a list found by derefrencing the arrarref</PRE>

<P>Try plugging that line into above script instead of the line from the
demo_calc.pl and you'll see different output. The line from demo_calc.pl
is in fact doing extra useless work. My guess is that the extra
    @{[    ]}
around there is one of two things:
    1) a momentary lapse of attention
       resulting in a copy/paste error, or duplicate typing
 or
    2) an artifact of earlier code wherein something extra was
       going on in there and has since been deleted.

</P>
<P>Even Damian can make a mistake, but it's not a mistake that affects
output... it just makes for a tiny bit of wasted work (or maybe Perl is
smart enough to optimze away the wasted work, I dunno).


</P><DT><A NAME="*%20Damian%20Conway%20says%3a">* Damian Conway says:

</A></DT>
<DD>

<P>I have no recollection of why I did this (see children, that's
why you should *always* comment your code!).

</P>
<P>I *suspect* it's vestigal -- from a time when contents of the
argument array reference were somehow modified in situ, but
it was important that the original argument's contents not
be changed.

</P>
<P>The ungainly <CODE>@{[@{$_[0]}]}</CODE> syntax is a way of (shallow)
copying the array referenced in $_[0] without declaring a new
variable. So another possible explanation is that evalop may
originally have been a one-liner, in which case I might have
used this &quot;inlined copy&quot; to keep the subroutine's body to a
single expression.

</P>
<P>However...

</P>
<PRE>   Even Damian can make a mistake</PRE>

<P>is by far the likeliest explanation.



</P></DD>
</DL>
<H1><A NAME="SEE%20ALSO">SEE ALSO

</A></H1>
<DL><DT><A NAME="*%20Parse%3a%3aRecdescent%20tutorial%20at%20www.perl.com">* Parse::Recdescent tutorial at www.perl.com

</A></DT>
<DD>
http://www.perl.com/pub/a/2001/06/13/recdecent.html

</DD>
<DT><A NAME="*%20py">* py

</A></DT>
<DD>

<P>py, which I assume is short for <CODE>parse yacc</CODE>, is a program by
Mark-Jason Dominus which parses GNU Bison output to produce Perl parsers.

</P>
<P>It is obtainable from http://perl.plover.com/py/

</P></DD>
<DT><A NAME="*%20Parse%3a%3aYAPP">* Parse::YAPP

</A></DT>
<DD>
A bottom-up parser which will be familiar to those who
have used Lex and Yacc. Parse::RecDescent is a top-down parser.

</DD>
<DT><A NAME="*%20Text%3a%3aBalanced">* Text::Balanced 

</A></DT>
<DD>
Use this instead of writing hairy regular expressions to match certain
common &quot;balanced&quot; forms of text, such as tags and parenthesized text.

</DD>
<DT><A NAME="*%20%22Mastering%20Regular%20Expressions%22%20by%20Jeffrey%20Freidl">* &quot;Mastering Regular Expressions&quot; by Jeffrey Freidl

</A></DT>
<DD>
You still need to know when to use /.*/ or /.+/ or /[^x]*/

</DD>
<DT><A NAME="*%20%22Object-Oriented%20Perl%22%20by%20Damian%20Conway">* &quot;Object-Oriented Perl&quot; by Damian Conway

</A></DT>
<DD>
This book will aid you in complexity management for large grammars.

</DD>
<DT><A NAME="*%20http%3a%2f%2fwww.PerlMonks.org">* http://www.PerlMonks.org

</A></DT>
<DD>
A useful site to get fast help on Perl.

</DD>
</DL>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>

<P>The author of Parse::RecDescent::FAQ is Terrence Brannon &lt;tbone@cpan.org&gt;. 

</P>
<P>The author of Parse::RecDescent is Damian Conway. 

</P>
<P>The (unwitting) contributors to this FAQ

</P><DL><DT><A NAME="*%20Me">* Me

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Damian%20Conway">* Damian Conway

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Marcel%20Grunaer">* Marcel Grunaer

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Brent%20Dax">* Brent Dax

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Randal%20L.%20Schwartz%20(merlyn)%2c%20Perl%20hacker">* Randal L. Schwartz (merlyn), Perl hacker

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20lhoward%20of%20Perlmonks">* lhoward of Perlmonks

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Matthew%20Wickline">* Matthew Wickline

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Gwynn%20Judd">* Gwynn Judd

</A></DT>
<DD>
</DD>
</DL>

</BODY>
</HTML>
